# COMPLETE VNF PROJECT CODE
# Virtual Network Function Service Function Chain Project
# Comprehensive Email Security Implementation with DRL+ARIMA Orchestration
# =================================================================

## PROJECT OVERVIEW
This project implements a comprehensive Virtual Network Function (VNF) Service Function Chain (SFC) 
for email security using Deep Reinforcement Learning (DRL) and ARIMA forecasting for intelligent 
orchestration and scaling.

## PROJECT STRUCTURE
- antivirus/ - Antivirus VNF implementation
- content_filtering/ - Content filtering and DLP VNF
- encryption_gateway/ - Email encryption/decryption VNF
- firewall/ - Network firewall VNF
- spamfilter/ - Spam detection VNF
- orchestration/ - Complete orchestration system with DRL+ARIMA
- scripts/ - Network topology and deployment scripts
- build_vnf_images.ps1 - PowerShell script for building all VNF images

## TECHNOLOGIES USED
- Python 3.8+
- Docker containers for VNFs
- Mininet for network simulation
- Prometheus for metrics collection
- Grafana for monitoring dashboards
- PyTorch for Deep Reinforcement Learning
- ARIMA for time series forecasting
- SDN controller for flow management

## PERFORMANCE TARGETS
- SFC Acceptance Ratio: 97%
- CPU Cycles Reduction: 45%
- Latency Improvement: 38%
- ARIMA Forecast Accuracy: 92%

================================================================================
1. ANTIVIRUS VNF (antivirus/antivirus.py)
================================================================================

#!/usr/bin/env python3
"""
Antivirus VNF - Content-based virus detection
Scans email content for virus signatures and malicious patterns
"""

import time
import hashlib
import threading
from datetime import datetime
from prometheus_client import start_http_server, Counter, Gauge, Histogram

class AntivirusVNF:
    def __init__(self):
        # Mock virus signatures (MD5 hashes of known malicious content)
        self.virus_signatures = {
            # Empty file hash (common in some attacks)
            "d41d8cd98f00b204e9800998ecf8427e": "Empty file virus",
            
            # Simple test virus signatures
            "5d41402abc4b2a76b9719d911017c592": "Test virus 'hello'",
            "098f6bcd4621d373cade4e832627b4f6": "Test virus 'test'",
            
            # Common malicious patterns (simplified)
            "a94a8fe5ccb19ba61c4c0873d391e987982fbbd3": "Malicious script pattern",
            "40bd001563085fc35165329ea1ff5c5ecbdbbeef": "Suspicious executable pattern"
        }
        
        # Suspicious patterns in content
        self.suspicious_patterns = [
            r'<script.*?>.*?</script>',  # JavaScript tags
            r'javascript:',              # JavaScript protocol
            r'vbscript:',                # VBScript protocol
            r'<iframe.*?>',              # IFrame tags
            r'<object.*?>',              # Object tags
            r'<embed.*?>',               # Embed tags
            r'<applet.*?>',              # Applet tags
            r'<form.*?>',                # Form tags (potential phishing)
            r'password.*?=.*?',          # Password fields
            r'credit.*?card.*?number',   # Credit card patterns
        ]
        
        # Statistics tracking
        self.stats = {
            'files_scanned': 0,
            'viruses_detected': 0,
            'suspicious_content': 0,
            'clean_files': 0
        }

        # Prometheus metrics
        self.emails_scanned_total = Counter(
            'antivirus_emails_scanned_total',
            'Total items scanned by antivirus',
            ['result']  # clean, infected, suspicious
        )
        self.scan_duration_seconds = Histogram(
            'antivirus_scan_duration_seconds',
            'Time spent scanning content'
        )

        # Start Prometheus metrics server on 8080
        start_http_server(8080)
        self.log("üìà Prometheus metrics server started on port 8080")
        
    def log(self, message):
        """Log antivirus activities with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[ANTIVIRUS {timestamp}] {message}")
        
    def scan_content(self, content, filename="unknown"):
        """
        Scan content for viruses and suspicious patterns
        
        Args:
            content (str): Content to scan
            filename (str): Name of the file being scanned
            
        Returns:
            dict: Scan results with status and details
        """
        start = time.time()
        self.stats['files_scanned'] += 1
        
        # Generate MD5 hash of content
        content_hash = hashlib.md5(content.encode('utf-8')).hexdigest()
        
        # Check for virus signatures
        if content_hash in self.virus_signatures:
            self.stats['viruses_detected'] += 1
            virus_name = self.virus_signatures[content_hash]
            self.emails_scanned_total.labels(result='infected').inc()
            self.scan_duration_seconds.observe(time.time() - start)
            self.log(f"ü¶† VIRUS DETECTED! File: {filename}")
            self.log(f"   Hash: {content_hash}")
            self.log(f"   Virus: {virus_name}")
            self.log(f"   Action: QUARANTINED")
            return {
                'status': 'infected',
                'virus_name': virus_name,
                'hash': content_hash,
                'action': 'quarantined'
            }
        
        # Check for suspicious patterns
        import re
        suspicious_found = []
        for pattern in self.suspicious_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                suspicious_found.append(pattern)
        
        if suspicious_found:
            self.stats['suspicious_content'] += 1
            self.emails_scanned_total.labels(result='suspicious').inc()
            self.scan_duration_seconds.observe(time.time() - start)
            self.log(f"‚ö†Ô∏è  SUSPICIOUS CONTENT DETECTED! File: {filename}")
            self.log(f"   Patterns: {suspicious_found}")
            self.log(f"   Action: FLAGGED FOR REVIEW")
            return {
                'status': 'suspicious',
                'patterns': suspicious_found,
                'action': 'flagged'
            }
        
        # Content is clean
        self.stats['clean_files'] += 1
        self.emails_scanned_total.labels(result='clean').inc()
        self.scan_duration_seconds.observe(time.time() - start)
        self.log(f"‚úÖ Content CLEAN. File: {filename}")
        self.log(f"   Hash: {content_hash}")
        return {
            'status': 'clean',
            'hash': content_hash,
            'action': 'allowed'
        }
    
    def scan_email_attachment(self, attachment_data, filename):
        """
        Scan email attachment for viruses
        
        Args:
            attachment_data (bytes): Raw attachment data
            filename (str): Attachment filename
            
        Returns:
            dict: Scan results
        """
        # Convert bytes to string for scanning (simplified)
        content = attachment_data.decode('utf-8', errors='ignore')
        return self.scan_content(content, filename)
    
    def get_statistics(self):
        """Return current antivirus statistics"""
        total = self.stats['files_scanned']
        if total == 0:
            return {
                'total_scanned': 0,
                'viruses_detected': 0,
                'suspicious_content': 0,
                'clean_files': 0,
                'detection_rate': 0.0
            }
        
        detection_rate = ((self.stats['viruses_detected'] + self.stats['suspicious_content']) / total) * 100
        
        return {
            'total_scanned': total,
            'viruses_detected': self.stats['viruses_detected'],
            'suspicious_content': self.stats['suspicious_content'],
            'clean_files': self.stats['clean_files'],
            'detection_rate': detection_rate
        }
    
    def simulate_email_scanning(self):
        """Simulate email content scanning for demonstration"""
        import random
        
        # Test email contents
        test_emails = [
            # Clean emails
            ("Meeting tomorrow", "Let's meet at 2 PM tomorrow for the project discussion."),
            ("Invoice #12345", "Please find attached invoice for services rendered."),
            ("Weekly report", "Here is the weekly progress report for your review."),
            
            # Suspicious emails
            ("Click here to win!", "<script>alert('You won!')</script> Click here to claim your prize!"),
            ("Password reset", "<form action='http://fake.com'>Enter your password: <input type='password'></form>"),
            ("Important document", "<iframe src='http://malicious.com'></iframe> Check this document."),
            
            # Virus-infected emails (using known hashes)
            ("Test virus", "hello"),  # Will trigger virus detection
            ("Empty file", ""),       # Will trigger virus detection
            ("Test content", "test"), # Will trigger virus detection
        ]
        
        for subject, content in test_emails:
            self.log(f"üìß Scanning email: '{subject[:30]}...'")
            result = self.scan_content(content, f"email_{subject[:10]}")
            
            if result['status'] == 'infected':
                self.log(f"üö´ Email BLOCKED due to virus")
            elif result['status'] == 'suspicious':
                self.log(f"‚ö†Ô∏è  Email FLAGGED for review")
            else:
                self.log(f"‚úÖ Email PASSED antivirus scan")
            
            time.sleep(3)  # Simulate processing time
    
    def start_service(self):
        """Start the antivirus VNF service"""
        self.log("üõ°Ô∏è  Antivirus VNF Started - Scanning Email Content")
        self.log(f"üìã Configuration:")
        self.log(f"   Virus Signatures: {len(self.virus_signatures)} patterns")
        self.log(f"   Suspicious Patterns: {len(self.suspicious_patterns)} rules")
        self.log(f"   Scanning: Email content and attachments")
        
        # Start statistics reporting thread
        def report_stats():
            while True:
                time.sleep(30)  # Report every 30 seconds
                stats = self.get_statistics()
                self.log(f"üìä Statistics: {stats['total_scanned']} files scanned, "
                        f"{stats['viruses_detected']} viruses, {stats['detection_rate']:.1f}% detection rate")
        
        stats_thread = threading.Thread(target=report_stats, daemon=True)
        stats_thread.start()
        
        # Main scanning loop
        try:
            while True:
                self.simulate_email_scanning()
                time.sleep(6)  # Wait before next simulation cycle
                
        except KeyboardInterrupt:
            self.log("üõë Antivirus VNF Shutting Down...")
            final_stats = self.get_statistics()
            self.log(f"üìà Final Statistics: {final_stats}")

if __name__ == "__main__":
    antivirus = AntivirusVNF()
    antivirus.start_service()

================================================================================
2. CONTENT FILTERING VNF (content_filtering/content_filtering.py)
================================================================================

#!/usr/bin/env python3
"""
Content Filtering VNF - Data loss prevention and policy enforcement
Detects sensitive data patterns and enforces content policies
"""

import time
import re
import threading
from datetime import datetime
from prometheus_client import start_http_server, Counter, Histogram

class ContentFilteringVNF:
    def __init__(self):
        # Prohibited content patterns (sensitive data detection)
        self.prohibited_patterns = {
            # Credit card patterns
            r'\b\d{4}[-.\s]?\d{4}[-.\s]?\d{4}[-.\s]?\d{4}\b': 'Credit card number',
            r'\b\d{4}[-.\s]?\d{6}[-.\s]?\d{5}\b': 'Credit card number (Amex)',
            
            # Social Security Number patterns
            r'\b\d{3}-\d{2}-\d{4}\b': 'Social Security Number',
            r'\b\d{9}\b': 'SSN (no dashes)',
            
            # Phone number patterns
            r'\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b': 'Phone number',
            r'\b\(\d{3}\)\s?\d{3}[-.\s]?\d{4}\b': 'Phone number (parentheses)',
            
            # Email patterns (for bulk email detection)
            r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b': 'Email address',
            
            # IP address patterns
            r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b': 'IP address',
            
            # Date patterns (for sensitive date detection)
            r'\b\d{1,2}[/-]\d{1,2}[/-]\d{2,4}\b': 'Date pattern',
            r'\b\d{4}-\d{2}-\d{2}\b': 'ISO date pattern'
        }
        
        # Blocked keywords and phrases
        self.blocked_keywords = [
            'internal use only',
            'classified',
            'top secret',
            'confidential',
            'proprietary',
            'trade secret',
            'for internal distribution only',
            'not for external use',
            'restricted access',
            'sensitive information',
            'private and confidential',
            'company confidential'
        ]
        
        # File type restrictions
        self.blocked_file_extensions = [
            '.exe', '.bat', '.cmd', '.com', '.pif', '.scr',
            '.vbs', '.js', '.jar', '.msi', '.dll', '.sys'
        ]
        
        # Size limits
        self.max_content_size = 10 * 1024 * 1024  # 10MB
        self.max_attachment_count = 5
        
        # Statistics tracking
        self.stats = {
            'content_scanned': 0,
            'policy_violations': 0,
            'sensitive_data_detected': 0,
            'content_blocked': 0,
            'content_allowed': 0
        }

        # Prometheus metrics
        self.content_scanned_total = Counter(
            'contentfilter_items_scanned_total',
            'Total content items scanned',
            ['status']  # approved, blocked
        )
        self.content_size_bytes = Histogram(
            'contentfilter_content_size_bytes',
            'Size of scanned content (bytes)'
        )
        self.sensitive_data_total = Counter(
            'contentfilter_sensitive_data_total',
            'Total instances where sensitive data was detected'
        )

        # Start metrics server
        start_http_server(8080)
        self.log("üìà Prometheus metrics server started on port 8080")
        
    def log(self, message):
        """Log content filtering activities with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[CONTENT_FILTER {timestamp}] {message}")
        
    def scan_content(self, content, filename="unknown", sender="unknown"):
        """
        Scan content for policy violations and sensitive data
        
        Args:
            content (str): Content to scan
            filename (str): Name of the file being scanned
            sender (str): Sender information
            
        Returns:
            dict: Scan results with violations and actions
        """
        self.stats['content_scanned'] += 1
        violations = []
        sensitive_data = []

        # Observe content size
        self.content_size_bytes.observe(len(content))
        
        # Check 1: Prohibited patterns (sensitive data)
        for pattern, description in self.prohibited_patterns.items():
            matches = re.findall(pattern, content, re.IGNORECASE)
            if matches:
                sensitive_data.append({
                    'type': description,
                    'count': len(matches),
                    'examples': matches[:3]  # Show first 3 examples
                })
                violations.append(f"Sensitive data detected: {description} ({len(matches)} instances)")
        
        # Check 2: Blocked keywords
        content_lower = content.lower()
        for keyword in self.blocked_keywords:
            if keyword.lower() in content_lower:
                violations.append(f"Blocked keyword: {keyword}")
        
        # Check 3: File size check
        if len(content) > self.max_content_size:
            violations.append(f"Content too large: {len(content)} bytes (max: {self.max_content_size})")
        
        # Check 4: File extension check
        if filename:
            file_ext = filename.lower()
            for ext in self.blocked_file_extensions:
                if file_ext.endswith(ext):
                    violations.append(f"Blocked file type: {ext}")
        
        # Check 5: Content length analysis
        if len(content) < 10:
            violations.append("Content too short (potential spam)")
        
        # Determine action based on violations
        if violations:
            self.stats['policy_violations'] += 1
            self.stats['content_blocked'] += 1
            
            if sensitive_data:
                self.stats['sensitive_data_detected'] += 1
                self.sensitive_data_total.inc()
                self.log(f"üö´ CONTENT BLOCKED - Sensitive Data Detected")
                self.log(f"   File: {filename}")
                self.log(f"   Sender: {sender}")
                self.log(f"   Violations: {violations}")
                self.log(f"   Action: BLOCKED - Data Loss Prevention")
            else:
                self.log(f"üö´ CONTENT BLOCKED - Policy Violation")
                self.log(f"   File: {filename}")
                self.log(f"   Sender: {sender}")
                self.log(f"   Violations: {violations}")
                self.log(f"   Action: BLOCKED")
            
            self.content_scanned_total.labels(status='blocked').inc()
            return {
                'status': 'blocked',
                'violations': violations,
                'sensitive_data': sensitive_data,
                'action': 'blocked',
                'reason': 'Policy violation'
            }
        else:
            self.stats['content_allowed'] += 1
            self.content_scanned_total.labels(status='approved').inc()
            self.log(f"‚úÖ Content APPROVED - No policy violations")
            self.log(f"   File: {filename}")
            self.log(f"   Sender: {sender}")
            self.log(f"   Size: {len(content)} bytes")
            return {
                'status': 'approved',
                'violations': [],
                'sensitive_data': [],
                'action': 'allowed',
                'reason': 'No violations'
            }
    
    def scan_email_attachments(self, attachments):
        """
        Scan email attachments for policy violations
        
        Args:
            attachments (list): List of attachment information
            
        Returns:
            dict: Attachment scan results
        """
        if len(attachments) > self.max_attachment_count:
            return {
                'status': 'blocked',
                'reason': f'Too many attachments: {len(attachments)} (max: {self.max_attachment_count})'
            }
        
        blocked_attachments = []
        for attachment in attachments:
            filename = attachment.get('filename', 'unknown')
            size = attachment.get('size', 0)
            
            # Check file extension
            for ext in self.blocked_file_extensions:
                if filename.lower().endswith(ext):
                    blocked_attachments.append(f"Blocked file type: {filename}")
                    break
            
            # Check file size
            if size > self.max_content_size:
                blocked_attachments.append(f"File too large: {filename} ({size} bytes)")
        
        if blocked_attachments:
            return {
                'status': 'blocked',
                'reason': 'Attachment policy violations',
                'violations': blocked_attachments
            }
        
        return {
            'status': 'approved',
            'reason': 'All attachments compliant'
        }
    
    def get_statistics(self):
        """Return current content filtering statistics"""
        total = self.stats['content_scanned']
        if total == 0:
            return {
                'total_scanned': 0,
                'policy_violations': 0,
                'sensitive_data_detected': 0,
                'content_blocked': 0,
                'content_allowed': 0,
                'block_rate': 0.0
            }
        
        block_rate = (self.stats['content_blocked'] / total) * 100
        
        return {
            'total_scanned': total,
            'policy_violations': self.stats['policy_violations'],
            'sensitive_data_detected': self.stats['sensitive_data_detected'],
            'content_blocked': self.stats['content_blocked'],
            'content_allowed': self.stats['content_allowed'],
            'block_rate': block_rate
        }
    
    def simulate_content_filtering(self):
        """Simulate content filtering for demonstration"""
        import random
        
        # Test content scenarios
        test_contents = [
            # Clean content
            {
                'content': 'Regular business email about project updates and meeting schedules.',
                'filename': 'meeting_notes.txt',
                'sender': 'john@company.com'
            },
            {
                'content': 'Weekly report with progress updates and next steps.',
                'filename': 'weekly_report.pdf',
                'sender': 'manager@corp.com'
            },
            
            # Content with sensitive data
            {
                'content': 'Please process payment with credit card: 4532-1234-5678-9012',
                'filename': 'payment_info.txt',
                'sender': 'finance@company.com'
            },
            {
                'content': 'Employee SSN: 123-45-6789 for tax purposes.',
                'filename': 'employee_data.txt',
                'sender': 'hr@company.com'
            },
            {
                'content': 'Contact me at john.doe@example.com or call 555-123-4567',
                'filename': 'contact_info.txt',
                'sender': 'john@company.com'
            },
            
            # Content with blocked keywords
            {
                'content': 'INTERNAL USE ONLY: Company financial data and projections.',
                'filename': 'financial_data.txt',
                'sender': 'finance@company.com'
            },
            {
                'content': 'This is CONFIDENTIAL information not for external use.',
                'filename': 'confidential.txt',
                'sender': 'executive@company.com'
            },
            
            # Large content
            {
                'content': 'A' * (self.max_content_size + 1000),  # Exceeds size limit
                'filename': 'large_file.txt',
                'sender': 'user@company.com'
            }
        ]
        
        for test_case in test_contents:
            self.log(f"üìÑ Scanning content: '{test_case['filename']}'")
            result = self.scan_content(
                test_case['content'],
                test_case['filename'],
                test_case['sender']
            )
            
            if result['status'] == 'blocked':
                self.log(f"üö´ Content BLOCKED: {result['reason']}")
            else:
                self.log(f"‚úÖ Content APPROVED")
            
            time.sleep(3)  # Simulate processing time
    
    def start_service(self):
        """Start the content filtering VNF service"""
        self.log("üõ°Ô∏è  Content Filtering VNF Started - Monitoring Content Policy")
        self.log(f"üìã Configuration:")
        self.log(f"   Prohibited Patterns: {len(self.prohibited_patterns)} rules")
        self.log(f"   Blocked Keywords: {len(self.blocked_keywords)} terms")
        self.log(f"   Max Content Size: {self.max_content_size} bytes")
        self.log(f"   Max Attachments: {self.max_attachment_count}")
        self.log(f"   Filtering: Data loss prevention and policy enforcement")
        
        # Start statistics reporting thread
        def report_stats():
            while True:
                time.sleep(30)  # Report every 30 seconds
                stats = self.get_statistics()
                self.log(f"üìä Statistics: {stats['total_scanned']} items scanned, "
                        f"{stats['content_blocked']} blocked ({stats['block_rate']:.1f}%)")
        
        stats_thread = threading.Thread(target=report_stats, daemon=True)
        stats_thread.start()
        
        # Main filtering loop
        try:
            while True:
                self.simulate_content_filtering()
                time.sleep(9)  # Wait before next simulation cycle
                
        except KeyboardInterrupt:
            self.log("üõë Content Filtering VNF Shutting Down...")
            final_stats = self.get_statistics()
            self.log(f"üìà Final Statistics: {final_stats}")

if __name__ == "__main__":
    content_filter = ContentFilteringVNF()
    content_filter.start_service()

================================================================================
3. ENCRYPTION GATEWAY VNF (encryption_gateway/encryption_gateway.py)
================================================================================

#!/usr/bin/env python3
"""
Encryption Gateway VNF - Email encryption and decryption
Provides data confidentiality for email communications
"""

import time
import base64
import hashlib
import threading
from datetime import datetime
from prometheus_client import start_http_server, Counter, Histogram

class EncryptionGatewayVNF:
    def __init__(self):
        # Encryption configuration
        self.encryption_key = "VNF_SECRET_KEY_2024_SFC_PROJECT"
        self.algorithm = "AES-256"  # Simulated algorithm name
        
        # Key management (simplified)
        self.key_rotation_interval = 3600  # 1 hour in seconds
        self.last_key_rotation = time.time()
        
        # Statistics tracking
        self.stats = {
            'emails_encrypted': 0,
            'emails_decrypted': 0,
            'encryption_errors': 0,
            'decryption_errors': 0,
            'total_processed': 0
        }

        # Prometheus metrics
        self.emails_processed_total = Counter(
            'encryption_emails_processed_total',
            'Total emails processed by encryption gateway',
            ['action']  # encrypt_success, decrypt_success, encrypt_error, decrypt_error
        )
        self.processing_seconds = Histogram(
            'encryption_processing_seconds',
            'Time spent processing emails'
        )

        # Start metrics server
        start_http_server(8080)
        self.log("üìà Prometheus metrics server started on port 8080")
        
    def log(self, message):
        """Log encryption activities with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[ENCRYPTION {timestamp}] {message}")
        
    def simple_encrypt(self, content):
        """
        Simple XOR encryption for demonstration
        In production, use proper cryptographic libraries like cryptography
        
        Args:
            content (str): Content to encrypt
            
        Returns:
            str: Base64 encoded encrypted content
        """
        try:
            encrypted = ""
            for i, char in enumerate(content):
                # XOR with key character (cycling through key)
                key_char = self.encryption_key[i % len(self.encryption_key)]
                encrypted += chr(ord(char) ^ ord(key_char))
            
            # Encode to base64 for safe transmission
            return base64.b64encode(encrypted.encode('utf-8')).decode('utf-8')
            
        except Exception as e:
            self.log(f"‚ùå Encryption error: {e}")
            self.stats['encryption_errors'] += 1
            return None
    
    def simple_decrypt(self, encrypted_content):
        """
        Simple XOR decryption for demonstration
        
        Args:
            encrypted_content (str): Base64 encoded encrypted content
            
        Returns:
            str: Decrypted content or None if error
        """
        try:
            # Decode from base64
            decoded = base64.b64decode(encrypted_content.encode('utf-8')).decode('utf-8')
            
            decrypted = ""
            for i, char in enumerate(decoded):
                # XOR with key character (cycling through key)
                key_char = self.encryption_key[i % len(self.encryption_key)]
                decrypted += chr(ord(char) ^ ord(key_char))
            
            return decrypted
            
        except Exception as e:
            self.log(f"‚ùå Decryption error: {e}")
            self.stats['decryption_errors'] += 1
            return None
    
    def process_email(self, content, direction="encrypt", email_id="unknown"):
        """
        Process email for encryption or decryption
        
        Args:
            content (str): Email content
            direction (str): 'encrypt' or 'decrypt'
            email_id (str): Email identifier for logging
            
        Returns:
            dict: Processing results
        """
        start = time.time()
        self.stats['total_processed'] += 1
        
        if direction == "encrypt":
            self.log(f"üîê Encrypting email: {email_id}")
            encrypted = self.simple_encrypt(content)
            
            if encrypted:
                self.stats['emails_encrypted'] += 1
                self.emails_processed_total.labels(action='encrypt_success').inc()
                self.processing_seconds.observe(time.time() - start)
                self.log(f"‚úÖ Email ENCRYPTED successfully")
                self.log(f"   Original: {content[:30]}...")
                self.log(f"   Encrypted: {encrypted[:30]}...")
                return {
                    'status': 'success',
                    'action': 'encrypted',
                    'original_length': len(content),
                    'encrypted_length': len(encrypted),
                    'result': encrypted
                }
            else:
                self.emails_processed_total.labels(action='encrypt_error').inc()
                self.processing_seconds.observe(time.time() - start)
                self.log(f"‚ùå Email encryption FAILED")
                return {
                    'status': 'error',
                    'action': 'encrypt_failed',
                    'error': 'Encryption failed'
                }
                
        elif direction == "decrypt":
            self.log(f"üîì Decrypting email: {email_id}")
            decrypted = self.simple_decrypt(content)
            
            if decrypted:
                self.stats['emails_decrypted'] += 1
                self.emails_processed_total.labels(action='decrypt_success').inc()
                self.processing_seconds.observe(time.time() - start)
                self.log(f"‚úÖ Email DECRYPTED successfully")
                self.log(f"   Encrypted: {content[:30]}...")
                self.log(f"   Decrypted: {decrypted[:30]}...")
                return {
                    'status': 'success',
                    'action': 'decrypted',
                    'encrypted_length': len(content),
                    'decrypted_length': len(decrypted),
                    'result': decrypted
                }
            else:
                self.emails_processed_total.labels(action='decrypt_error').inc()
                self.processing_seconds.observe(time.time() - start)
                self.log(f"‚ùå Email decryption FAILED")
                return {
                    'status': 'error',
                    'action': 'decrypt_failed',
                    'error': 'Decryption failed'
                }
        
        else:
            self.log(f"‚ùå Invalid direction: {direction}")
            return {
                'status': 'error',
                'action': 'invalid_direction',
                'error': f'Invalid direction: {direction}'
            }
    
    def rotate_encryption_key(self):
        """Rotate encryption key for security"""
        import secrets
        import string
        
        # Generate new key
        alphabet = string.ascii_letters + string.digits
        new_key = ''.join(secrets.choice(alphabet) for i in range(32))
        
        self.encryption_key = new_key
        self.last_key_rotation = time.time()
        self.log(f"üîÑ Encryption key rotated: {new_key[:10]}...")
    
    def get_statistics(self):
        """Return current encryption statistics"""
        return {
            'total_processed': self.stats['total_processed'],
            'emails_encrypted': self.stats['emails_encrypted'],
            'emails_decrypted': self.stats['emails_decrypted'],
            'encryption_errors': self.stats['encryption_errors'],
            'decryption_errors': self.stats['decryption_errors'],
            'success_rate': ((self.stats['emails_encrypted'] + self.stats['emails_decrypted']) / 
                           max(1, self.stats['total_processed'])) * 100
        }
    
    def simulate_email_processing(self):
        """Simulate email encryption/decryption for demonstration"""
        import random
        
        # Test email contents
        test_emails = [
            "Confidential business proposal for Q4 2024",
            "Personal message to friend about weekend plans",
            "Financial transaction details and account information",
            "Sensitive project data and strategic planning",
            "Private communication between executives",
            "Contract negotiations and legal documents",
            "Employee performance review and feedback",
            "Customer data and privacy information"
        ]
        
        for i, content in enumerate(test_emails):
            email_id = f"email_{i+1:03d}"
            
            # Simulate encryption
            self.log(f"üìß Processing: {email_id}")
            encrypt_result = self.process_email(content, "encrypt", email_id)
            
            if encrypt_result['status'] == 'success':
                encrypted_content = encrypt_result['result']
                
                # Simulate decryption
                time.sleep(2)  # Simulate processing delay
                decrypt_result = self.process_email(encrypted_content, "decrypt", email_id)
                
                if decrypt_result['status'] == 'success':
                    decrypted_content = decrypt_result['result']
                    if decrypted_content == content:
                        self.log(f"‚úÖ Round-trip encryption/decryption successful")
                    else:
                        self.log(f"‚ùå Round-trip encryption/decryption failed")
            
            time.sleep(4)  # Wait before next email
    
    def start_service(self):
        """Start the encryption gateway VNF service"""
        self.log("üîê Encryption Gateway VNF Started - Processing Email Encryption")
        self.log(f"üìã Configuration:")
        self.log(f"   Algorithm: {self.algorithm}")
        self.log(f"   Key Rotation: Every {self.key_rotation_interval} seconds")
        self.log(f"   Processing: Email encryption and decryption")
        
        # Start key rotation thread
        def key_rotation():
            while True:
                time.sleep(self.key_rotation_interval)
                self.rotate_encryption_key()
        
        rotation_thread = threading.Thread(target=key_rotation, daemon=True)
        rotation_thread.start()
        
        # Start statistics reporting thread
        def report_stats():
            while True:
                time.sleep(30)  # Report every 30 seconds
                stats = self.get_statistics()
                self.log(f"üìä Statistics: {stats['total_processed']} emails, "
                        f"{stats['success_rate']:.1f}% success rate")
        
        stats_thread = threading.Thread(target=report_stats, daemon=True)
        stats_thread.start()
        
        # Main processing loop
        try:
            while True:
                self.simulate_email_processing()
                time.sleep(8)  # Wait before next simulation cycle
                
        except KeyboardInterrupt:
            self.log("üõë Encryption Gateway VNF Shutting Down...")
            final_stats = self.get_statistics()
            self.log(f"üìà Final Statistics: {final_stats}")

if __name__ == "__main__":
    encryption_gateway = EncryptionGatewayVNF()
    encryption_gateway.start_service()
